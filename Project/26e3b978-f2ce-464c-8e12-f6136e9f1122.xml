<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>WaitNextScan := TRUE;&#xD;
REPEAT&#xD;
CASE Drive1.St OF &#xD;
	&#xD;
	DS_Idle:&#xD;
	&#xD;
		IF Drive1.PrevSpeed &lt;&gt; Drive1.Speed THEN // Only update speed if it is 'fresh'&#xD;
			Drive1.St := DS_SetSpeed;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive1.Accel &lt;&gt; Drive1.PrevAccel THEN&#xD;
			Drive1.St := DS_SetAccel;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive1.Decel &lt;&gt; Drive1.PrevDecel THEN&#xD;
			Drive1.St := DS_SetDecel;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive1.TqLim &lt;&gt; Drive1.PrevTqLim THEN&#xD;
			Drive1.St := DS_SetTorque;&#xD;
			WaitNextScan := FALSE;&#xD;
		// Only get alm/wng if speed not changed&#xD;
		// This value can be changed once we know time to write&#xD;
		// But must prevent alarm read from overlapping next speed write&#xD;
		ELSIF EC_BLVL_ALM1 AND AlmCnt &gt;= AlmInt AND TrackingCount = 0  THEN &#xD;
			Drive1.St := DS_GetAlm;&#xD;
			AlmCnt := 0;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF EC_BLVL_WARN AND WngCnt &gt;= WngInt AND TrackingCount = 0  THEN&#xD;
			Drive1.St := DS_GetWng;&#xD;
			WngCnt := 0;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive1.ReqReset THEN&#xD;
			Drive1.St := DS_ResetAlm;&#xD;
			WaitNextScan := FALSE;&#xD;
		END_IF;&#xD;
		&#xD;
		IF AlmCnt &lt;= AlmInt THEN Inc(AlmCnt); END_IF;&#xD;
		IF WngCnt &lt;= WngInt THEN Inc(WngCnt); END_IF;&#xD;
		IF TqCnt  &lt;= TqlInt  THEN Inc(TqCnt);  END_IF;&#xD;
		EC_BLVL_TRIG :=	FALSE;&#xD;
&#xD;
&#xD;
	DS_SetSpeed:&#xD;
		// Write speed to 'Rotational Speed No.2' (1242h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE &#xD;
			EC_BLVL_CMD := UINT#16#1242;&#xD;
			EC_BLVL_DATA := Drive1.Speed;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitSetSpeed;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetSpeed:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.PrevSpeed := EC_BLVL_DATAR;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			TimeToWrite := TrackingCount;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_GetAlm:&#xD;
		// Read 'Present Alarm' (2040h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVL_CMD := UINT#16#2040;&#xD;
			EC_BLVL_DATA := 0;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitGetAlm;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_SetAccel:&#xD;
		// Write accel to 'Acceleration No.2' (1302h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVL_CMD := UINT#16#1302;&#xD;
			EC_BLVL_DATA := Drive1.Accel;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitSetAccel;&#xD;
		END_IF;	&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetAccel:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.PrevAccel := Drive1.Accel;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_SetDecel:&#xD;
		// Write accel to 'Deceleration No.2' (1342h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVL_CMD := UINT#16#1342;&#xD;
			EC_BLVL_DATA := Drive1.Decel;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitSetDecel;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetDecel:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.PrevDecel := EC_BLVL_DATAR;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; 		&#xD;
	&#xD;
	DS_SetTorque:&#xD;
		// Write torque to 'Torque Limit No.2' (1382h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVL_CMD := UINT#16#1382;&#xD;
			EC_BLVL_DATA := Drive1.TqLim;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitSetTorque;&#xD;
		END_IF;&#xD;
		&#xD;
	DS_WaitSetTorque:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.PrevTqLim := EC_BLVL_DATAR;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
		WaitNextScan := TRUE;&#xD;
	&#xD;
	DS_GetTorque:&#xD;
		// Read 'Load Factor' (2084h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVL_CMD := UINT#16#2086;&#xD;
			EC_BLVL_DATA := 0;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitGetTorque;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitGetTorque:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.Torque := EC_BLVL_DATAR;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
	&#xD;
	DS_WaitGetAlm:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.Alarm := DINT_TO_WORD(EC_BLVL_DATAR);&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
	&#xD;
	DS_GetWng:&#xD;
		// Read 'Present Warning' (204Bh)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVL_CMD := UINT#16#204B;&#xD;
			EC_BLVL_DATA := 0;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitGetWng;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitGetWng:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.Warning := DINT_TO_WORD(EC_BLVL_DATAR);&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
			Drive1.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_ResetAlm:&#xD;
		// Write 1 to 'Reset Alarm' (30C0h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVL_CMD := UINT#16#30c0;&#xD;
			EC_BLVL_DATA := 1;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitClearReset;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitResetAlm:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.St := DS_ClearReset;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		END_IF;&#xD;
		&#xD;
	DS_ClearReset:&#xD;
		// Write 0 to 'Reset Alarm' (30C0h)&#xD;
		IF EC_BLVL_TRIGR THEN&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVL_CMD := UINT#16#30c0;&#xD;
			EC_BLVL_DATA := 0;&#xD;
			EC_BLVL_TRIG := TRUE;&#xD;
			Drive1.St := DS_WaitClearReset;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitClearReset:&#xD;
		IF EC_BLVL_ADRERR OR EC_BLVL_DATERR THEN&#xD;
			Drive1.St := DS_HandleFault;&#xD;
		// Check for ack&#xD;
		ELSIF EC_BLVL_TRIGR THEN&#xD;
			Drive1.St := DS_Idle;&#xD;
			Drive1.ReqReset := 0;&#xD;
			EC_BLVL_TRIG := FALSE;&#xD;
		END_IF;	&#xD;
	&#xD;
	DS_HandleFault:&#xD;
		EC_BLVL_TRIG := FALSE;&#xD;
		Drive1.St := DS_Idle;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
ELSE&#xD;
	Drive1.St := DS_Idle;&#xD;
	WaitNextScan := TRUE;&#xD;
		&#xD;
END_CASE;&#xD;
		// If initialisation requested, set all diffs to -1 to force update&#xD;
IF Drive1.ReqInit THEN&#xD;
	Drive1.PrevAccel := -1;&#xD;
	Drive1.PrevDecel := -1;&#xD;
	Drive1.PrevTqLim := -1;&#xD;
	Drive1.PrevSpeed := -1;&#xD;
	Drive1.ReqInit := FALSE;&#xD;
END_IF;&#xD;
&#xD;
// If all required parameters have been set, drive is ready.&#xD;
IF  Drive1.PrevAccel &lt;&gt; -1&#xD;
AND Drive1.PrevDecel &lt;&gt; -1&#xD;
AND Drive1.PrevTqLim &lt;&gt; -1&#xD;
AND Drive1.PrevSpeed &lt;&gt; -1 THEN&#xD;
	Drive1.Ready := TRUE;&#xD;
ELSE&#xD;
	Drive1.Ready := FALSE;&#xD;
END_IF;&#xD;
&#xD;
// Hard Timeout&#xD;
IF Drive1.St &lt;&gt; Drive1.PrevSt OR Drive1.St = DS_Idle THEN&#xD;
	TimeInState := 0;&#xD;
ELSE &#xD;
	Inc(TimeInState);&#xD;
END_IF;&#xD;
IF TimeInState &gt; 500 (*1s*) THEN &#xD;
	Drive1.St := DS_HandleFault;&#xD;
END_IF;&#xD;
Drive1.PrevSt := Drive1.St;&#xD;
UNTIL WaitNextScan END_REPEAT;&#xD;
</Text></StructuredTextModel>