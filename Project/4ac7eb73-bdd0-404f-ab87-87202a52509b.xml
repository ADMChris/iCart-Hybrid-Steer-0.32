<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>WaitNextScan := TRUE;&#xD;
REPEAT&#xD;
CASE Drive2.St OF &#xD;
	&#xD;
	DS_Idle:&#xD;
	&#xD;
		IF Drive2.PrevSpeed &lt;&gt; Drive2.Speed AND TrackingCount &lt; 2 THEN&#xD;
			Drive2.St := DS_SetSpeed;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive2.Accel &lt;&gt; Drive2.PrevAccel THEN&#xD;
			Drive2.St := DS_SetAccel;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive2.Decel &lt;&gt; Drive2.PrevDecel THEN&#xD;
			Drive2.St := DS_SetDecel;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive2.TqLim &lt;&gt; Drive2.PrevTqLim THEN&#xD;
			Drive2.St := DS_SetTorque;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF EC_BLVR_ALM1 AND AlmCnt &gt;= AlmInt AND TrackingCount = 0 THEN&#xD;
			Drive2.St := DS_GetAlm;&#xD;
			AlmCnt := 0;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF EC_BLVR_WARN AND WngCnt &gt;= WngInt AND TrackingCount = 0 THEN&#xD;
			Drive2.St := DS_GetWng;&#xD;
			WngCnt := 0;&#xD;
			WaitNextScan := FALSE;&#xD;
		ELSIF Drive2.ReqReset THEN&#xD;
			Drive2.St := DS_ResetAlm;&#xD;
			WaitNextScan := FALSE;&#xD;
		END_IF;&#xD;
		&#xD;
		IF AlmCnt &lt;= AlmInt THEN Inc(AlmCnt); END_IF;&#xD;
		IF WngCnt &lt;= WngInt THEN Inc(WngCnt); END_IF;&#xD;
		EC_BLVR_TRIG :=	FALSE;&#xD;
&#xD;
	DS_SetSpeed:&#xD;
		// Write speed to 'Rotational Speed No.2' (1242h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE &#xD;
			EC_BLVR_CMD := UINT#16#1242;&#xD;
			EC_BLVR_DATA := Drive2.Speed * 2;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitSetSpeed;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetSpeed:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.PrevSpeed := EC_BLVR_DATAR / 2;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_GetAlm:&#xD;
		// Read 'Present Alarm' (2040h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVR_CMD := UINT#16#2040;&#xD;
			EC_BLVR_DATA := 0;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitGetAlm;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
			&#xD;
	DS_SetAccel:&#xD;
		// Write accel to 'Acceleration No.2' (1302h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVR_CMD := UINT#16#1302;&#xD;
			EC_BLVR_DATA := Drive2.Accel;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitSetAccel;&#xD;
		END_IF;	&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetAccel:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.PrevAccel := Drive2.Accel;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_SetDecel:&#xD;
		// Write accel to 'Deceleration No.2' (1342h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVR_CMD := UINT#16#1342;&#xD;
			EC_BLVR_DATA := Drive2.Decel;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitSetDecel;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetDecel:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.PrevDecel := EC_BLVR_DATAR;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; 		&#xD;
	&#xD;
	DS_SetTorque:&#xD;
		// Write torque to 'Torque Limit No.2' (1382h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVR_CMD := UINT#16#1382;&#xD;
			EC_BLVR_DATA := Drive2.TqLim;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitSetTorque;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitSetTorque:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.PrevTqLim := EC_BLVR_DATAR;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; 	&#xD;
	&#xD;
	DS_GetTorque:&#xD;
		// Read 'Load Factor' (2084h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVR_CMD := UINT#16#2086;&#xD;
			EC_BLVR_DATA := 0;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitGetTorque;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitGetTorque:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.Torque := EC_BLVR_DATAR;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; &#xD;
	&#xD;
	&#xD;
	DS_WaitGetAlm:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.Alarm := DINT_TO_WORD(EC_BLVR_DATAR);&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; &#xD;
	&#xD;
	DS_GetWng:&#xD;
		// Read 'Present Warning' (204Bh)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVR_CMD := UINT#16#204B;&#xD;
			EC_BLVR_DATA := 0;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitGetWng;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitGetWng:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.Warning := DINT_TO_WORD(EC_BLVR_DATAR);&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
			Drive2.St := DS_Idle;&#xD;
		END_IF; &#xD;
		&#xD;
	DS_ResetAlm:&#xD;
		// Write 1 to 'Reset Alarm' (30C0h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE		&#xD;
			EC_BLVR_CMD := UINT#16#30c0;&#xD;
			EC_BLVR_DATA := 1;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitClearReset;&#xD;
		END_IF;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
	DS_WaitResetAlm:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.St := DS_ClearReset;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		END_IF;&#xD;
		&#xD;
	DS_ClearReset:&#xD;
		// Write 0 to 'Reset Alarm' (30C0h)&#xD;
		IF EC_BLVR_TRIGR THEN&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		ELSE&#xD;
			EC_BLVR_CMD := UINT#16#30c0;&#xD;
			EC_BLVR_DATA := 0;&#xD;
			EC_BLVR_TRIG := TRUE;&#xD;
			Drive2.St := DS_WaitClearReset;&#xD;
		END_IF;&#xD;
		&#xD;
	DS_WaitClearReset:&#xD;
		IF EC_BLVR_ADRERR OR EC_BLVR_DATERR THEN&#xD;
			Drive2.St := DS_HandleFault;&#xD;
		// Check for ack&#xD;
		ELSIF EC_BLVR_TRIGR THEN&#xD;
			Drive2.St := DS_Idle;&#xD;
			Drive2.ReqReset := 0;&#xD;
			EC_BLVR_TRIG := FALSE;&#xD;
		END_IF;	&#xD;
	&#xD;
	DS_HandleFault:&#xD;
		EC_BLVR_TRIG := FALSE;&#xD;
		Drive2.St := DS_Idle;&#xD;
		WaitNextScan := TRUE;&#xD;
		&#xD;
ELSE&#xD;
	Drive2.St := DS_Idle;&#xD;
		&#xD;
END_CASE;&#xD;
		&#xD;
// If initialisation requested, set all diffs to -1 to force update&#xD;
IF Drive2.ReqInit THEN&#xD;
	Drive2.PrevAccel := -1;&#xD;
	Drive2.PrevDecel := -1;&#xD;
	Drive2.PrevTqLim := -1;&#xD;
	Drive2.PrevSpeed := -1;&#xD;
	Drive2.ReqInit := FALSE;&#xD;
END_IF;&#xD;
&#xD;
// If all required parameters have been set, drive is ready.&#xD;
IF  Drive2.PrevAccel &lt;&gt; -1&#xD;
AND Drive2.PrevDecel &lt;&gt; -1&#xD;
AND Drive2.PrevTqLim &lt;&gt; -1&#xD;
AND Drive2.PrevSpeed &lt;&gt; -1 THEN&#xD;
	Drive2.Ready := TRUE;&#xD;
ELSE&#xD;
	Drive2.Ready := FALSE;&#xD;
END_IF;&#xD;
&#xD;
// Hard Timeout&#xD;
IF Drive2.St &lt;&gt; Drive2.PrevSt OR Drive2.St = DS_Idle THEN&#xD;
	TimeInState := 0;&#xD;
ELSE &#xD;
	Inc(TimeInState);&#xD;
END_IF;&#xD;
IF TimeInState &gt; 500 (*1s*) THEN &#xD;
	Drive2.St := DS_HandleFault;&#xD;
END_IF;&#xD;
Drive2.PrevSt := Drive2.St;&#xD;
UNTIL WaitNextScan END_REPEAT;</Text></StructuredTextModel>