<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* iTruck Tracking Algorithm - Copyright 2018 TAG Ltd. *)&#xD;
&#xD;
ManualOverride := JoystickSpeed &gt; 10 AND JoystickSteer &gt; 0;&#xD;
ManualReverse := JoystickSpeed &gt; 10 AND JoystickSpeed &lt; 1400;&#xD;
&#xD;
Sensor.AsWord := SensorInWord;&#xD;
&#xD;
IF AGVDirection = TurnLeft THEN&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[14]:=FALSE;											(* Falling Edge 14 *)&#xD;
	IF Sensor.Bit[14]=TRUE THEN										(* Rising Edge 14 *)&#xD;
		RisingEdge[14]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[14]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 13 TO 0 BY -1 DO&#xD;
		IF (NOT Sensor.Bit[a] AND Sensor.Bit[a+1]) OR (FallingEdge[a+1]=TRUE) THEN					(* Falling Edge a *)&#xD;
			FallingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a+1]=TRUE) OR ((Sensor.Bit[a]=TRUE)AND(Sensor.Bit[a+1]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
(* Right Turn *)&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[0]:=FALSE;												(* Falling Edge 0 *)&#xD;
	IF Sensor.Bit[0]=TRUE THEN											(* Rising Edge 0 *)&#xD;
		RisingEdge[0]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[0]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 0 TO 13 DO&#xD;
		IF (NOT Sensor.Bit[a+1] AND Sensor.Bit[a]) OR (FallingEdge[a]=TRUE) THEN						(* Falling Edge a *)&#xD;
			FallingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a]=TRUE) OR ((Sensor.Bit[a+1]=TRUE)AND(Sensor.Bit[a]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
RisingEdges := 0;&#xD;
FallingEdges := 0;&#xD;
FOR a := 0 TO 13 DO&#xD;
	IF RisingEdge[a] THEN Inc(RisingEdges); END_IF;&#xD;
	IF FallingEdge[a] THEN Inc(FallingEdges); END_IF;&#xD;
END_FOR;&#xD;
(* Set Active Sensors *)&#xD;
TempSensorPosition := 0.0;&#xD;
TempNoSensors := 0;&#xD;
MaxSensors := 3;&#xD;
IF AGVDirection = TurnRight THEN&#xD;
	FOR a := 0 TO 14 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
	FOR a := 14 TO 0 BY -1 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
IF (TempSensorPosition &gt; 0.0) AND (TempNoSensors &gt; 0) THEN&#xD;
	SensorPosition := (TempSensorPosition/INT_TO_REAL(TempNoSensors));&#xD;
ELSE&#xD;
	SensorPosition := 8.0;&#xD;
END_IF;&#xD;
IF SensorPosition &gt; 14.0 THEN SensorPosition := 14.0; END_IF;&#xD;
Error := (SensorPosition - 8.0) / 7.0; // Normalise: -1 to 1, center 0&#xD;
&#xD;
&#xD;
(* Determine Sensor count *)&#xD;
SensorCount := 0.0;&#xD;
FOR a := 0 TO 14 DO&#xD;
	IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE))) THEN&#xD;
		SensorCount := SensorCount + 1.0;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
ForkDetected := SensorCount &gt; 5.0;&#xD;
(* If Sensor count too great, then override Sensor position to middle value*)&#xD;
If (SensorCount &gt;=7.0) THEN&#xD;
	Error := 0.0;&#xD;
END_IF;&#xD;
IF (SensorCount = 0.0) THEN&#xD;
   TapeDetected := FALSE;&#xD;
ELSE&#xD;
	TapeDetected := TRUE;&#xD;
	&#xD;
END_IF;&#xD;
G_SensorCount := SensorCount;&#xD;
&#xD;
TapePosition := Error;&#xD;
(* --- TRACKING FUNCTION --- *)&#xD;
&#xD;
Derivative :=  Error - DelayLine[0];&#xD;
&#xD;
Integral := 0;&#xD;
FOR a:=0 TO IntTime BY 1 DO&#xD;
	Integral := Integral + DelayLine[a];&#xD;
END_FOR;&#xD;
&#xD;
IF NOT ManualOverride &#xD;
	AND NOT SpinStateActive &#xD;
	AND NOT TagTestActive &#xD;
	AND NOT HMIJogLeft &#xD;
	AND NOT HMIJogRight &#xD;
	THEN //if not manual override or tag request tracking control is controlled by PID&#xD;
	ControlOutput :=  (Error * (Kp) + (Derivative * Kd) + (Integral * Ki));&#xD;
ELSE&#xD;
	ControlOutput := INT_TO_REAL(JoystickSteer-1400) * Kjst;&#xD;
END_IF;&#xD;
&#xD;
// output on global for stepper&#xD;
Tracking_ControlOutput := ControlOutput;&#xD;
&#xD;
&#xD;
&#xD;
&#xD;
(* --- CORNER DETECT --- *)&#xD;
&#xD;
CorneringIntegral := 0;&#xD;
FOR a:=0 TO CorneringTime BY 1 DO&#xD;
	CorneringIntegral := CorneringIntegral + abs(DelayLine[a]);&#xD;
END_FOR;&#xD;
&#xD;
IF CorneringIntegral &lt; 10 THEN CorneringIntegral := 10; END_IF;&#xD;
CorneringIntegral := CorneringIntegral - 10;&#xD;
&#xD;
CorneringFactor := 1-(CorneringIntegral * Kcf);&#xD;
&#xD;
&#xD;
&#xD;
(* --- DELAY LINE --- *)&#xD;
&#xD;
FOR a := 0 TO 254 BY 1 DO&#xD;
	DelayLine[a+1] := DelayLine[a];&#xD;
END_FOR;&#xD;
&#xD;
// Anti Windup&#xD;
// Might need to move this down &amp; use internalSpeed if some fault conditions fail to trigger this&#xD;
//IF Speed = 0 OR AGVRunning = FALSE THEN&#xD;
	//DelayLine[0] := 0;&#xD;
//ELSE&#xD;
	DelayLine[0] := Error;&#xD;
//END_IF;&#xD;
&#xD;
(* --- OFF TRACK DETECT ---*)&#xD;
&#xD;
TrackLost := NOT TapeDetected;&#xD;
&#xD;
(* --- CONTROLLED STOP &amp; OFF TRACK LOCKOUT --- *)&#xD;
&#xD;
&#xD;
&#xD;
IF AGVRunning AND NOT (ManualOverride OR PauseAGV OR StopAGV) THEN&#xD;
	&#xD;
    InternalSpeed := Speed;&#xD;
  	AccelRate := REAL_TO_INT(AccelSteps);&#xD;
	&#xD;
ELSIF ManualOverride THEN&#xD;
	InternalSpeed := ABS(INT_TO_REAL(JoystickSpeed-1400)) * Kjsp;&#xD;
	AccelRate := REAL_TO_INT(JoystickAccel);&#xD;
ELSE&#xD;
		InternalSpeed := 0.0;&#xD;
		IF StopAGV OR PauseAGV THEN&#xD;
			AccelRate := 200;&#xD;
		ELSE&#xD;
			AccelRate := REAL_TO_INT(AccelSteps);&#xD;
		END_IF;&#xD;
END_IF;&#xD;
&#xD;
(* --- CALCULATE OUTPUTS --- *)&#xD;
&#xD;
// Corner Slowdown&#xD;
IF RampSpeedOut &gt; 10&#xD;
   AND RampSpeedOut * CorneringFactor &lt; CreepSpeed * 2 &#xD;
THEN&#xD;
	RampSpeedOut := CreepSpeed * 2;&#xD;
ELSE&#xD;
	RampSpeedOut := RampSpeedOut * CorneringFactor;&#xD;
END_IF;&#xD;
&#xD;
(* --- ACCELERATION --- *)&#xD;
IF ABS(InternalSpeed) &lt;&gt; ABS(RampSpeedOut) THEN&#xD;
	RampSpeedOut := RampSpeed_Prev + (InternalSpeed - RampSpeed_Prev) / AccelRate;&#xD;
	&#xD;
	// Deceleration - Cutoff // IF rampspeed falls below a creep speed and is greater than internal speed, then set rampspeed to zero.&#xD;
	IF ABS(RampSpeedOut) &lt; CreepSpeed &#xD;
		AND ABS(RampSpeedOut) &gt; ABS(InternalSpeed)&#xD;
	THEN&#xD;
		RampSpeedOut := 0; &#xD;
	END_IF;&#xD;
	&#xD;
	// Acceleration - Clamp&#xD;
	IF ABS(RampSpeedOut) &lt; ABS(InternalSpeed) &#xD;
		AND ABS(RampSpeedOut) &gt; ABS(InternalSpeed) - 25&#xD;
	THEN&#xD;
		RampSpeedOut := InternalSpeed; &#xD;
	END_IF;&#xD;
	&#xD;
END_IF;&#xD;
RampSpeed_Prev := RampSpeedOut;&#xD;
&#xD;
RampSpeedOut := RampSpeedOut * CorneringFactor;&#xD;
&#xD;
&#xD;
&#xD;
// Steering - We don't want this for hybrid steer!&#xD;
// Need to replace with differential algorithm at some point&#xD;
// for now just map speed directly &amp; drop torque limit on inside whee&#xD;
&#xD;
//LeftSpeedReal := RampSpeedOut;//&#xD;
//RightSpeedReal := RampSpeedOut;//&#xD;
&#xD;
//Calculate motor speed based from turning radius of wheels. &#xD;
//HomePos - Actpos = Difference Value.&#xD;
//Difference Value / 388.8 = Degrees Traveled. &#xD;
//PrevDegreesTraveled := Degrees Traveled. &#xD;
//stepper motor = 0.072 degrees/step &#xD;
//center point is 55,000 and travels to 22,000 for right turn (+90degrees) and to 90,000 for left turn (-90degrees).&#xD;
//no. of steps per revolution = 360/degrees per step or 360/0.072 = 5000steps per revolution (360). &#xD;
//180 degrees = 2500 steps. //90degrees = 1250 steps. 1 degree = 0.072 steps. &#xD;
//in 90 degrees the stepper travels 35,000 each way to complete action.&#xD;
//So 1 degree of change over 35,000 == 35,000/90 = +/-388.8 position change per step/degree.&#xD;
//this would be the change in value in relevence to tape position. 	&#xD;
	&#xD;
(*Steps to Degrees (90) &amp; (-90) degrees*)&#xD;
&#xD;
Degrees_per_step := 388.8; // 1 degree of movement in decimal. &#xD;
&#xD;
&#xD;
//Difference in steering angle//&#xD;
Steering_Difference_Value 	:= DINT_TO_REAL(Steering_Home - (AZD_ActPos)); //Set Home position as start and minus actual pos to make home 0 degrees point.&#xD;
&#xD;
//Angle in Degrees Calc//&#xD;
Angle_Degrees			  	:= Steering_Difference_Value/ (Degrees_per_step);&#xD;
DegAngle := Angle_Degrees;&#xD;
&#xD;
IF TagRequestedSpeed = Fast THEN&#xD;
&#xD;
RampSpeedOut := RampSpeedOut * (1 - ( Kcf * Angle_Degrees));&#xD;
&#xD;
END_IF;&#xD;
&#xD;
//Convert Degrees to Steps//&#xD;
Deg_To_Steps 				:= (Angle_Degrees) / 0.072;&#xD;
&#xD;
&#xD;
(*DIffSteering*)&#xD;
&#xD;
&#xD;
//Calculations//&#xD;
Drive_track_m 					:= 0.74; 	//Distance between centers of Driving wheels. &#xD;
&#xD;
Wheel_Base_m 					:= 0.9; 	//Distance between ceneters of steering and Driving axel. &#xD;
&#xD;
Gear_Ratio 						:= 30; 		//specified gear ratio for drive motors. &#xD;
&#xD;
Wheel_Radius 					:= 0.08; 	//Radius of Drive motor wheels. &#xD;
&#xD;
PI 								:= 3.14;		//Approx PI rate. &#xD;
&#xD;
wheel_C 							:= Wheel_Radius * 3.14 * 2;&#xD;
&#xD;
DistancePerMotorRev_m 			:= (Wheel_Radius * PI * 2) / Gear_Ratio;// Distance Travelled (in m) per turn of the Motor. &#xD;
&#xD;
Steering_Angle_BelowAxel 		:= 90 - Angle_Degrees;&#xD;
&#xD;
Steering_angle_belowAxelRads  	:= Steering_Angle_BelowAxel * PI / 180;&#xD;
&#xD;
Wheel_Base_Squared_m				:= Wheel_Base_m * Wheel_Base_m;&#xD;
&#xD;
motor_center_radius_Squared 		:= motor_center_radius * motor_center_radius;&#xD;
&#xD;
&#xD;
//convert deg to rads Calc//&#xD;
	&#xD;
Angle_rad := (Angle_Degrees * PI)/180;&#xD;
&#xD;
//Calc Center Axel Turn Radius//	&#xD;
&#xD;
motor_center_radius := Wheel_Base_m * (TAN(Steering_angle_belowAxelRads));&#xD;
&#xD;
//Front Axel Radius Calcs//&#xD;
&#xD;
frontaxelradius := (Wheel_Base_Squared_m  + motor_center_radius_Squared);&#xD;
frontaxelradius_Sq := SQRT(frontaxelradius);&#xD;
&#xD;
&#xD;
//Calc Outer Turning Radius//&#xD;
MotorOuterRadius := motor_center_radius + (Drive_track_m/2);&#xD;
&#xD;
//Calc Inner Turn Radius//&#xD;
motorinnerRadius := motor_center_radius - (Drive_track_m/2);&#xD;
&#xD;
//Calc Diff Ratio - Outside Wheel//&#xD;
diff_drive_ratio := MotorOuterRadius / motorinnerRadius;&#xD;
&#xD;
//Calc Diff Ratio - Inside Wheel//&#xD;
diff_drive_ratio_In :=  motorinnerRadius / MotorOuterRadius;&#xD;
&#xD;
&#xD;
&#xD;
//Running Program for iTruck Hybrid Diff Steering//&#xD;
IF AGVRunning AND Angle_Degrees = 0 THEN; &#xD;
	&#xD;
&#xD;
//Normalise Inner and Outer Radius//&#xD;
&#xD;
motorinnerRadius := ABS (motorinnerRadius);&#xD;
MotorOuterRadius := ABS(MotorOuterRadius);&#xD;
&#xD;
END_IF;&#xD;
&#xD;
//Hybrid Steering Diff for Right Turn//&#xD;
IF (Angle_Degrees &gt; 20) THEN&#xD;
	&#xD;
	//Leftspeed &amp; RightSpeed in Meters per sec//&#xD;
	LeftSpeed_ms 		:= 		RampSpeedOut;&#xD;
	RightSpeed_ms 		:= 		(RampSpeedOut / MotorOuterRadius) * motorinnerRadius;&#xD;
	&#xD;
	//Set both speeds against Speed Real to then be Multiplied by 2 as normal for etherCAT drives//&#xD;
	LeftSpeedReal  		:= 		LeftSpeed_ms ;&#xD;
	RightSpeedReal 		:= 		RightSpeed_ms;&#xD;
&#xD;
	&#xD;
&#xD;
//Hybrid Steering Diff for left Turn//&#xD;
ELSIF (Angle_Degrees &lt; -20) THEN&#xD;
	&#xD;
	//Leftspeed &amp; Rightspeed in Meters per sec//&#xD;
	LeftSpeed_ms	:= 		(RampSpeedOut / MotorInnerRadius) * motorOuterRadius;&#xD;
	RightSpeed_ms:=		RampSpeedOut;&#xD;
	&#xD;
	//Set both speeds against speed real to then be multiplied by 2 as normal for EtherCAT drives//&#xD;
	LeftSpeedReal 	:= LeftSpeed_ms;&#xD;
	RightSpeedReal 	:= leftspeed_ms - RightSpeed_ms;&#xD;
	&#xD;
	&#xD;
ELSE &#xD;
	//Anything less than these steering angles, set both left and right speeds to rampspeed//&#xD;
	LeftSpeedReal := RampSpeedOut;&#xD;
	RightSpeedReal := RampSpeedOut;&#xD;
&#xD;
END_IF;&#xD;
	&#xD;
&#xD;
&#xD;
/////&#xD;
// Speed control for spin state of stepper motor. &#xD;
////&#xD;
&#xD;
//Set control for spin speed from spin states. &#xD;
&#xD;
&#xD;
IF  SpinSetSpeed THEN   //was 320&#xD;
	LeftSpeedReal 	:= 200;&#xD;
	RightSpeedReal 	:= 200;&#xD;
END_IF;&#xD;
&#xD;
//Speed control for fast spin tag. &#xD;
&#xD;
IF SpinDegSpeed THEN&#xD;
	LeftSpeedReal	:= 500; //speed upped to 1000 rpm on each wheel. &#xD;
	RightSpeedReal	:= 500;	//"									  "	&#xD;
END_IF;&#xD;
&#xD;
&#xD;
// HMI Jog&#xD;
IF HMIJogFwd OR HMIJogRev OR HMIJogLeft OR HMIJogRight THEN&#xD;
	LeftSpeedReal := CreepSpeed * 4.0;&#xD;
	RightSpeedReal := CreepSpeed * 4.0;&#xD;
ELSIF HMIJogFast THEN&#xD;
	LeftSpeedReal := 3000;&#xD;
	RightSpeedReal := 3000;&#xD;
END_IF;&#xD;
// Clamp Minimum Values&#xD;
IF LeftSpeedReal  &lt; CreepSpeed AND LeftSpeedReal  &gt; 10 THEN LeftSpeedReal  := CreepSpeed * 2; END_IF;&#xD;
IF RightSpeedReal &lt; CreepSpeed AND RightSpeedReal &gt; 10 THEN RightSpeedReal := CreepSpeed * 2; END_IF;&#xD;
&#xD;
//IF LeftSpeedReal &lt; 50 THEN LeftSpeedReal := 50; END_IF;&#xD;
//IF RightSpeedReal &lt; 50 THEN RightSpeedReal := 50; END_IF;&#xD;
&#xD;
IF LeftSpeedReal  &lt; 10 THEN LeftSpeedReal  := 0; END_IF;&#xD;
IF RightSpeedReal &lt;	10 THEN RightSpeedReal := 0; END_IF;&#xD;
&#xD;
&#xD;
(* Convert to int - double for etherCAT to maintain original scale from analog card *)&#xD;
LeftSpeedOut  := REAL_TO_INT(LeftSpeedReal) * 2;&#xD;
RightSpeedOut := REAL_TO_INT(RightSpeedReal) * 2;&#xD;
LeftSpeed_ms := LeftSpeed_ms;&#xD;
RightSpeed_ms := RightSpeed_ms;&#xD;
&#xD;
(* Clamp Maximum Values *)&#xD;
IF LeftSpeedOut &gt; 4000 THEN&#xD;
	LeftSpeedOut := 4000;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
IF RightSpeedOut &gt; 4000 THEN&#xD;
	RightSpeedOut := 4000;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
// Copy into drive structure for EtherCAT converter&#xD;
Drive1.Speed := LeftSpeedOut;&#xD;
Drive2.Speed := RightSpeedOut;&#xD;
&#xD;
ActualSpeed := (RightSpeedReal + LeftSpeedReal) / 2;&#xD;
&#xD;
Speed_ms := (((ActualSpeed * 2) / 30) * 0.5025) / 60;&#xD;
&#xD;
CycleTime_Sec  := LINT_TO_REAL(TimeToNanoSec(GetMyTaskInterval())) / REAL#1000000000;&#xD;
&#xD;
Odometer_mm := Odometer_mm + Speed_ms  * CycleTime_Sec * 1000;&#xD;
&#xD;
IF Odometer_mm &gt; 1000 THEN&#xD;
	Inc(Odometer_m);&#xD;
	Clear(Odometer_mm);&#xD;
END_IF;&#xD;
&#xD;
&#xD;
</Text></StructuredTextModel>