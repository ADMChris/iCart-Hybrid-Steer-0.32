<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(* iTruck Tracking Algorithm - Copyright 2018 TAG Ltd. *)&#xD;
&#xD;
ManualOverride := JoystickSpeed &gt; 10 AND JoystickSteer &gt; 0;&#xD;
ManualReverse := JoystickSpeed &gt; 10 AND JoystickSpeed &lt; 1400;&#xD;
&#xD;
Sensor.AsWord := SensorInWord;&#xD;
&#xD;
IF AGVDirection = TurnLeft THEN&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[14]:=FALSE;											(* Falling Edge 14 *)&#xD;
	IF Sensor.Bit[14]=TRUE THEN										(* Rising Edge 14 *)&#xD;
		RisingEdge[14]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[14]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 13 TO 0 BY -1 DO&#xD;
		IF (NOT Sensor.Bit[a] AND Sensor.Bit[a+1]) OR (FallingEdge[a+1]=TRUE) THEN					(* Falling Edge a *)&#xD;
			FallingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a+1]=TRUE) OR ((Sensor.Bit[a]=TRUE)AND(Sensor.Bit[a+1]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
(* Right Turn *)&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[0]:=FALSE;												(* Falling Edge 0 *)&#xD;
	IF Sensor.Bit[0]=TRUE THEN											(* Rising Edge 0 *)&#xD;
		RisingEdge[0]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[0]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 0 TO 13 DO&#xD;
		IF (NOT Sensor.Bit[a+1] AND Sensor.Bit[a]) OR (FallingEdge[a]=TRUE) THEN						(* Falling Edge a *)&#xD;
			FallingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a]=TRUE) OR ((Sensor.Bit[a+1]=TRUE)AND(Sensor.Bit[a]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
RisingEdges := 0;&#xD;
FallingEdges := 0;&#xD;
FOR a := 0 TO 13 DO&#xD;
	IF RisingEdge[a] THEN Inc(RisingEdges); END_IF;&#xD;
	IF FallingEdge[a] THEN Inc(FallingEdges); END_IF;&#xD;
END_FOR;&#xD;
(* Set Active Sensors *)&#xD;
TempSensorPosition := 0.0;&#xD;
TempNoSensors := 0;&#xD;
MaxSensors := 3;&#xD;
IF AGVDirection = TurnRight THEN&#xD;
	FOR a := 0 TO 14 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
	FOR a := 14 TO 0 BY -1 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
IF (TempSensorPosition &gt; 0.0) AND (TempNoSensors &gt; 0) THEN&#xD;
	SensorPosition := (TempSensorPosition/INT_TO_REAL(TempNoSensors));&#xD;
ELSE&#xD;
	SensorPosition := 8.0;&#xD;
END_IF;&#xD;
IF SensorPosition &gt; 13.0 THEN SensorPosition := 14.0; END_IF;&#xD;
Error := (SensorPosition - 8.0) / 7.0; // Normalise: -1 to 1, center 0&#xD;
&#xD;
(*IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
	&#xD;
	SteeringPos :=  DINT_TO_REAL (AZD_ActPos);&#xD;
&#xD;
//HomePos - Actpos = Difference Value.&#xD;
//Difference Value / 388.8 = Degrees Traveled. &#xD;
//PrevDegreesTraveled := Degrees Traveled. &#xD;
	&#xD;
	&#xD;
END_IF;*)&#xD;
&#xD;
Degrees_per_step := 388.8; // 1 degree of movement in decimal. &#xD;
&#xD;
&#xD;
&#xD;
Steering_Difference_Value 	:= DINT_TO_REAL(Steering_Home - AZD_ActPos);&#xD;
Degrees_Travelled  			:= (Steering_Difference_Value) / (Degrees_per_step);&#xD;
Prev_Degrees_Travelled		:= Degrees_Travelled;&#xD;
&#xD;
&#xD;
(* Determine Sensor count *)&#xD;
SensorCount := 0.0;&#xD;
FOR a := 0 TO 14 DO&#xD;
	IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE))) THEN&#xD;
		SensorCount := SensorCount + 1.0;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
ForkDetected := SensorCount &gt; 5.0;&#xD;
(* If Sensor count too great, then override Sensor position to middle value*)&#xD;
If (SensorCount &gt;=7.0) THEN&#xD;
	Error := 0.0;&#xD;
END_IF;&#xD;
IF (SensorCount = 0.0) THEN&#xD;
   TapeDetected := FALSE;&#xD;
ELSE&#xD;
	TapeDetected := TRUE;&#xD;
	&#xD;
END_IF;&#xD;
G_SensorCount := SensorCount;&#xD;
&#xD;
TapePosition := Error;&#xD;
(* --- TRACKING FUNCTION --- *)&#xD;
&#xD;
Derivative :=  Error - DelayLine[0];&#xD;
&#xD;
Integral := 0;&#xD;
FOR a:=0 TO IntTime BY 1 DO&#xD;
	Integral := Integral + DelayLine[a];&#xD;
END_FOR;&#xD;
&#xD;
IF NOT ManualOverride AND NOT SpinStateActive THEN //if not manual override or tag request tracking control is controlled by PID&#xD;
	ControlOutput :=  Error * Kp + Derivative * Kd + Integral * Ki;&#xD;
ELSE&#xD;
	ControlOutput := INT_TO_REAL(JoystickSteer-1400) * Kjst;&#xD;
END_IF;&#xD;
&#xD;
// output on global for stepper&#xD;
Tracking_ControlOutput := ControlOutput;&#xD;
&#xD;
//stepper motor = 0.072 degrees/step &#xD;
//center point is 55,000 and travels to 22,000 for right turn (+90degrees) and to 90,000 for left turn (-90degrees).&#xD;
//no. of steps per revolution = 360/degrees per step or 360/0.072 = 5000steps per revolution (360). &#xD;
//180 degrees = 2500 steps. //90degrees = 1250 steps. 1 degree = 0.072 steps. &#xD;
//in 90 degrees the stepper travels 35,000 each way to complete action.&#xD;
//So 1 degree of change over 35,000 == 35,000/90 = +/-388.8 per step/degree.&#xD;
//this would be the change in value in relevence to tape position. &#xD;
&#xD;
&#xD;
(* --- CORNER DETECT --- *)&#xD;
&#xD;
CorneringIntegral := 0;&#xD;
FOR a:=0 TO CorneringTime BY 1 DO&#xD;
	CorneringIntegral := CorneringIntegral + abs(DelayLine[a]);&#xD;
END_FOR;&#xD;
&#xD;
IF CorneringIntegral &lt; 10 THEN CorneringIntegral := 10; END_IF;&#xD;
CorneringIntegral := CorneringIntegral - 10;&#xD;
&#xD;
CorneringFactor := 1-(CorneringIntegral * Kcf);&#xD;
&#xD;
(* --- DELAY LINE --- *)&#xD;
&#xD;
FOR a := 0 TO 254 BY 1 DO&#xD;
	DelayLine[a+1] := DelayLine[a];&#xD;
END_FOR;&#xD;
&#xD;
// Anti Windup&#xD;
// Might need to move this down &amp; use internalSpeed if some fault conditions fail to trigger this&#xD;
//IF Speed = 0 OR AGVRunning = FALSE THEN&#xD;
	//DelayLine[0] := 0;&#xD;
//ELSE&#xD;
	DelayLine[0] := Error;&#xD;
//END_IF;&#xD;
&#xD;
(* --- OFF TRACK DETECT ---*)&#xD;
&#xD;
TrackLost := NOT TapeDetected;&#xD;
&#xD;
(* --- CONTROLLED STOP &amp; OFF TRACK LOCKOUT --- *)&#xD;
&#xD;
IF AGVRunning AND NOT (ManualOverride OR PauseAGV OR StopAGV) THEN&#xD;
    InternalSpeed := Speed;&#xD;
  	AccelRate := REAL_TO_INT(AccelSteps);&#xD;
ELSIF ManualOverride THEN&#xD;
	InternalSpeed := ABS(INT_TO_REAL(JoystickSpeed-1400)) * Kjsp;&#xD;
	AccelRate := REAL_TO_INT(JoystickAccel);&#xD;
ELSE&#xD;
		InternalSpeed := 0.0;&#xD;
		IF StopAGV OR PauseAGV THEN&#xD;
			AccelRate := 200;&#xD;
		ELSE&#xD;
			AccelRate := REAL_TO_INT(AccelSteps);&#xD;
		END_IF;&#xD;
END_IF;&#xD;
&#xD;
(* --- ACCELERATION --- *)&#xD;
IF ABS(InternalSpeed) &lt;&gt; ABS(RampSpeedOut) THEN&#xD;
	RampSpeedOut := RampSpeed_Prev + (InternalSpeed - RampSpeed_Prev) / AccelRate;&#xD;
	&#xD;
	// Deceleration - Cutoff&#xD;
	IF ABS(RampSpeedOut) &lt; CreepSpeed &#xD;
		AND ABS(RampSpeedOut) &gt; ABS(InternalSpeed)&#xD;
	THEN&#xD;
		RampSpeedOut := 0; &#xD;
	END_IF;&#xD;
	&#xD;
	// Acceleration - Clamp&#xD;
	IF ABS(RampSpeedOut) &lt; ABS(InternalSpeed) &#xD;
		AND ABS(RampSpeedOut) &gt; ABS(InternalSpeed) - 25&#xD;
	THEN&#xD;
		RampSpeedOut := InternalSpeed; &#xD;
	END_IF;&#xD;
	&#xD;
END_IF;&#xD;
RampSpeed_Prev := RampSpeedOut;&#xD;
&#xD;
&#xD;
(* --- CALCULATE OUTPUTS --- *)&#xD;
&#xD;
// Corner Slowdown&#xD;
IF RampSpeedOut &gt; 10 &#xD;
   AND RampSpeedOut * CorneringFactor &lt; CreepSpeed * 2 &#xD;
THEN&#xD;
	RampSpeedOut := CreepSpeed * 2;&#xD;
ELSE&#xD;
	RampSpeedOut := RampSpeedOut * CorneringFactor;&#xD;
END_IF;&#xD;
&#xD;
(*IF TagRequestLS OR TagRequestRS THEN;&#xD;
	TrackLost := FALSE; &#xD;
END_IF;*)&#xD;
&#xD;
&#xD;
// Steering - We don't want this for hybrid steer!&#xD;
// Need to replace with differential algorithm at some point&#xD;
// for now just map speed directly &amp; drop torque limit on inside wheel&#xD;
LeftSpeedReal := RampSpeedOut;&#xD;
RightSpeedReal := RampSpeedOut;&#xD;
(*&#xD;
IF ControlOutput &lt; 0 THEN&#xD;
	LeftSpeedReal  := RampSpeedOut * (1 + ABS(ControlOutput));&#xD;
	RightSpeedReal := RampSpeedOut * (1 - ABS(ControlOutput));&#xD;
ELSE&#xD;
	LeftSpeedReal  := RampSpeedOut * (1 - ABS(ControlOutput));&#xD;
	RightSpeedReal := RampSpeedOut * (1 + ABS(ControlOutput));&#xD;
END_IF;*)&#xD;
&#xD;
/////&#xD;
// Speed control for spin state of stepper motor. &#xD;
////&#xD;
&#xD;
//Set control for spin speed from spin states. &#xD;
&#xD;
&#xD;
IF  SpinSetSpeed THEN&#xD;
	LeftSpeedReal 	:= 320;&#xD;
	RightSpeedReal 	:= 320;&#xD;
END_IF;&#xD;
&#xD;
//Speed control for fast spin tag. &#xD;
&#xD;
IF SpinDegSpeed THEN&#xD;
	LeftSpeedOut	:= 500; //speed upped to 1000 rpm on each wheel. &#xD;
	RightSpeedOut	:= 500;	//"									  "	&#xD;
END_IF;&#xD;
&#xD;
&#xD;
// HMI Jog&#xD;
IF HMIJogFwd OR HMIJogRev OR HMIJogLeft OR HMIJogRight THEN&#xD;
	LeftSpeedReal := CreepSpeed * 4.0;&#xD;
	RightSpeedReal := CreepSpeed * 4.0;&#xD;
ELSIF HMIJogFast THEN&#xD;
	LeftSpeedReal := 3000;&#xD;
	RightSpeedReal := 3000;&#xD;
END_IF;&#xD;
// Clamp Minimum Values&#xD;
IF LeftSpeedReal  &lt; CreepSpeed AND LeftSpeedReal  &gt; 10 THEN LeftSpeedReal  := CreepSpeed; END_IF;&#xD;
IF RightSpeedReal &lt; CreepSpeed AND RightSpeedReal &gt; 10 THEN RightSpeedReal := CreepSpeed; END_IF;&#xD;
IF LeftSpeedReal  &lt; 10 THEN LeftSpeedReal  := 0; END_IF;&#xD;
IF RightSpeedReal &lt;	10 THEN RightSpeedReal := 0; END_IF;&#xD;
&#xD;
(* Convert to int - double for etherCAT to maintain original scale from analog card *)&#xD;
LeftSpeedOut  := REAL_TO_INT(LeftSpeedReal) * 2;&#xD;
RightSpeedOut := REAL_TO_INT(RightSpeedReal) * 2;&#xD;
&#xD;
(* Clamp Maximum Values *)&#xD;
IF LeftSpeedOut &gt; 4000 THEN&#xD;
	LeftSpeedOut := 4000;&#xD;
END_IF;&#xD;
&#xD;
IF RightSpeedOut &gt; 4000 THEN&#xD;
	RightSpeedOut := 4000;&#xD;
END_IF;&#xD;
&#xD;
// Copy into drive structure for EtherCAT converter&#xD;
Drive1.Speed := LeftSpeedOut;&#xD;
Drive2.Speed := RightSpeedOut;&#xD;
&#xD;
ActualSpeed := TestSpeed + (RightSpeedReal + LeftSpeedReal);&#xD;
&#xD;
&#xD;
	&#xD;
&#xD;
</Text></StructuredTextModel>