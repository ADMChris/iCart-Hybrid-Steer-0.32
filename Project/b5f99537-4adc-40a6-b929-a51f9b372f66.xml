<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>(*This case statement covers the spin right feature of the iCart, where the iCart will... &#xD;
&gt; Stop iCart Drives "SS_BLV_stp"  and give permission to "spinstateactive" to deactivate Tracklost and tape track features. &#xD;
&gt; Set "PrevPos" = 0; and AZD set steering position to current pos. &#xD;
&gt; Set AZD steering pos to right steering pos. &#xD;
&gt; Wait until AZD is in pos. &#xD;
&gt; when in pos, un-stop and set rear drives to spin on spot and set speed &gt; Spin until Sensor Count for tape tracking is &gt;= 4 &#xD;
&gt; When tape is found, stop iCart and recenter azd to "Steering_home" to center drive &#xD;
&gt; Set Spinstateactive to false to give tape control back to do tracking*)&#xD;
&#xD;
////////////////////////////&#xD;
//Case for Spin state Right.&#xD;
////////////////////////////&#xD;
&#xD;
CASE SpinstateR OF&#xD;
	&#xD;
	SS_idle:&#xD;
	&#xD;
			TagDriveSetR	:=  FALSE; //Set drive spin request false to not spin on spot and giveway to normal motoion. &#xD;
			SpinStateReset	:=  FALSE; //Set reset state false.&#xD;
			&#xD;
			IF Spinright THEN&#xD;
				&#xD;
				SpinStateComplete 	:= FALSE;	//deactivate AGV running set. &#xD;
			&#xD;
				SpinstateR 			:= SS_WaitToStop; //move to next state.&#xD;
		&#xD;
			END_IF;&#xD;
			&#xD;
&#xD;
	SS_WaitToStop:&#xD;
	&#xD;
		SpinPause		:= TRUE; 		//Activates PauseAGV.&#xD;
		SS_BLV_Stp		:= TRUE;		//Sets BLV_Stop true to stop Rear Drives.&#xD;
		SS_BLV_MBFREE	:= TRUE;		//Set MBFREE True.&#xD;
		SpinStateActive := TRUE;		//Removes tape tracking control and allows free setting for the AZD Drive. &#xD;
		PrevSetPos		:= 0;			//Set Previous pos to 0 to set a new position. &#xD;
		AZD_SetPos 		:= AZD_ActPos;	//Set current pos to new pos to keep drive central. &#xD;
		&#xD;
		&#xD;
			IF AGVStopped AND (LeftSpeedOut = 0) AND (RightSpeedOut = 0) THEN&#xD;
				&#xD;
				PrevSetPos 		:= 0;				//Set Previous pos to 0 to set a new position. &#xD;
				AZD_SetPos		:= Steering_Home;	//set pos to home.&#xD;
				&#xD;
				SpinstateR 	:= SS_AZDSetR;&#xD;
			&#xD;
			ELSIF TimeInState &gt; 2000 THEN&#xD;
				&#xD;
				SpinstateR := SS_HandleFault;&#xD;
				&#xD;
			END_IF;&#xD;
	&#xD;
&#xD;
	SS_AZDSetR:&#xD;
		&#xD;
			SS_BLV_Stp	:= TRUE;&#xD;
			PrevSetPos 	:= 0;							//Set Previous pos to 0 to set a new position. &#xD;
			AZD_SetPos 	:= Steering_Rightpos;	//Set Current pos to go to right steering pos.&#xD;
			&#xD;
			SpinstateR 	:= SS_WaitforAZDSet;&#xD;
			&#xD;
		&#xD;
	SS_WaitforAZDSet:&#xD;
	&#xD;
&#xD;
		&#xD;
		IF (AZD_ActPos &lt;= -17000) THEN&#xD;
			&#xD;
			SpinstateR 		:= SS_SpinR;&#xD;
			&#xD;
			&#xD;
		ELSIF (TimeInState &gt; 3000) //give 6 secs to position steering&#xD;
				AND (AZD_ActPos &gt; -22500)&#xD;
				AND RetryCount &lt; 3 //If try count is not above threshold. &#xD;
				THEN&#xD;
			&#xD;
			// set drive back to Home and retry past state. &#xD;
			PrevSetPos 		:= 0;&#xD;
			AZD_SetPos 		:= Steering_Home;&#xD;
			Inc(RetryCount);&#xD;
			SpinstateR 		:= SS_AZDSetR;&#xD;
			&#xD;
			//If Retry Count goes above threshold, Move to handle Fault state. &#xD;
			IF RetryCount = 3 THEN&#xD;
				&#xD;
				SpinstateR :=  SS_HandleFault;&#xD;
				&#xD;
			END_IF;&#xD;
		&#xD;
		//Default Spin reset feature. &#xD;
		ELSIF SpinStateReset THEN&#xD;
			&#xD;
			SpinStateR := SS_Reset;&#xD;
			&#xD;
		END_IF;&#xD;
		&#xD;
	SS_SpinSet90:&#xD;
	&#xD;
	IF (AZD_SetPos &lt;= -22500) THEN&#xD;
		&#xD;
		Spin_RightRealSpeed		:= 500;&#xD;
		Spin_LeftRealSpeed		:= 500;&#xD;
		Spin_Distance 			:= 0.0;&#xD;
		&#xD;
		SpinstateR := SS_Spin90;&#xD;
	END_IF;&#xD;
	&#xD;
	SS_SpinSet180:&#xD;
	&#xD;
	IF (AZD_SetPos &lt;= -22500) THEN&#xD;
		&#xD;
		Spin_RightRealSpeed		:= 500; //Set speeds to 1000m/s for a fast spin (Speeds are *2 when in working state so 500*2 = 1000. &#xD;
		Spin_LeftRealSpeed		:= 500;&#xD;
		Spin_Distance 			:= 0.0;	//set spin distance to 0 to be incremented in state later on. &#xD;
		&#xD;
		SpinstateR := SS_Spin180;&#xD;
	END_IF;&#xD;
	&#xD;
	&#xD;
	SS_Spin90: &#xD;
	&#xD;
		SS_BLV_Stp		:= FALSE;	//Set BLV_stop to false.&#xD;
		SS_BLV_MBFREE	:= FALSE;	//Set MBFREE. &#xD;
		SpinPause 		:= FALSE;	//set pause to false. &#xD;
		TagDriveSetR 	:= TRUE;	//set drives to spin. &#xD;
		SpinSetSpeed 	:= FALSE;	//Set SPin speed value to overwirte speed. //if spin 90 or 180 then set this false. &#xD;
		SpinDegSpeed	:= TRUE;	//set speed to special spin speed. (1000rpm)&#xD;
		DriveSpin 		:= TRUE;	//Activate Drive Power. &#xD;
		Spin_Distance 	:= Spin_Distance + 0.25; //possibly to change to 0.16.&#xD;
		&#xD;
		IF Spin_Distance &gt;= 0.5 THEN;&#xD;
			&#xD;
			SpinSetSpeed		:= TRUE; &#xD;
			SpinDegSpeed		:= FALSE;&#xD;
			Spin_Distance		:= 0.0;&#xD;
			SpinstateR			:= SS_WaitforTape;&#xD;
		END_IF;&#xD;
	&#xD;
	&#xD;
	SS_Spin180:&#xD;
	&#xD;
		SS_BLV_Stp		:= FALSE;	//Set BLV_stop to false.&#xD;
		SS_BLV_MBFREE	:= FALSE;	//Set MBFREE. &#xD;
		SpinPause 		:= FALSE;	//set pause to false. &#xD;
		TagDriveSetR 	:= TRUE;	//set drives to spin. &#xD;
		SpinSetSpeed 	:= FALSE;	//Set SPin speed value to overwirte speed. //if spin 90 or 180 then set this false. &#xD;
		DriveSpin 		:= TRUE;	//Activate Drive Power. &#xD;
		Spin_Distance 	:= Spin_Distance + 0.55; //possibly need to change. &#xD;
		&#xD;
		IF Spin_Distance &gt;= 1.1 THEN;&#xD;
			&#xD;
			Spin_LeftRealSpeed 	:= 320; //NEED TO MAP SPEEDS THROUGH DO TRACKING.&#xD;
			Spin_RightRealSpeed := 320;&#xD;
			Spin_Distance		:= 0.0;&#xD;
			SpinstateR			:= SS_WaitforTape;&#xD;
		END_IF;&#xD;
		&#xD;
		&#xD;
	SS_SpinR:&#xD;
	&#xD;
		SS_BLV_Stp		:= FALSE;	//Set BLV_stop to false.&#xD;
		SS_BLV_MBFREE	:= FALSE;	//Set MBFREE. &#xD;
		SpinPause 		:= FALSE;	//set pause to false. &#xD;
		TagDriveSetR 	:= TRUE;	//set drives to spin. &#xD;
		SpinSetSpeed 	:= TRUE;	//Set SPin speed value to overwirte speed. //if spin 90 or 180 then set this false. &#xD;
		DriveSpin 		:= TRUE;	//Activate Drive Power. &#xD;
		RetryCount	:= 0;&#xD;
		SpinStateActive := TRUE;&#xD;
		&#xD;
		SpinstateR 		:= SS_WaitforTape;&#xD;
			&#xD;
		IF TimeInState &gt; 3000 THEN&#xD;
			SpinstateR := SS_HandleFault;&#xD;
		END_IF;&#xD;
		&#xD;
	SS_WaitforTape:&#xD;
	&#xD;
		IF G_SensorCount &gt;= 4 THEN			//IF tape sensor see's more than 4...&#xD;
			&#xD;
			SpinstateR := SS_TapeDetect;	//Move to next state. &#xD;
			&#xD;
		ELSIF (TimeInState &gt; 7500) AND (NOT ScanWarnLow AND NOT ScanWarnHigh)  THEN //greater than 15 secs// &#xD;
			&#xD;
			SpinstateR := SS_HandleFault;	//Handle Fault&#xD;
			&#xD;
			&#xD;
		ELSIF ScanWarnLow OR ScanWarnHigh = TRUE THEN&#xD;
			&#xD;
			TimeInState := 0; &#xD;
			&#xD;
			IF ScanWarnLow AND ScanWarnLow = FALSE THEN&#xD;
				&#xD;
				SpinstateR := SS_SpinR;&#xD;
			END_IF;&#xD;
			&#xD;
			&#xD;
		ELSIF SpinStateReset THEN			// IF reset function is activated then...&#xD;
			SpinStateR := SS_Reset;			//Move to reset state. &#xD;
			&#xD;
		END_IF;	&#xD;
&#xD;
&#xD;
	SS_TapeDetect:&#xD;
		&#xD;
		//SS_BLV_Stp		:= 	TRUE;	//SET blv_Stop variable true and stop rear drives. &#xD;
		SpinPause 		:= 	TRUE;&#xD;
		SpinSetSpeed	:=  FALSE; // disable spin speed. &#xD;
		TagDriveSetR	:=  FALSE;&#xD;
		SpinStateActive	:=	TRUE;&#xD;
		SS_BLV_Stp		:=  TRUE;&#xD;
		&#xD;
		SpinstateR := SS_AZDCenter;			// Move to center drive once tape found. &#xD;
	&#xD;
	&#xD;
	SS_AZDCenter:&#xD;
			&#xD;
		//PrevSetPos 	:= 0; 	//set previous pos to 0;&#xD;
		&#xD;
		//AZD_SetPos	:= Steering_Home;//set current position back to home. &#xD;
		&#xD;
		IF (AZD_ActPos &lt;= 10900) AND (LeftSpeedOut = 0) AND (RightSpeedOut = 0) THEN	&#xD;
			&#xD;
			PrevSetPos 	:= 0; 	//set previous pos to 0;&#xD;
		&#xD;
			AZD_SetPos	:= Steering_Home;//set current position back to home.&#xD;
			&#xD;
			//SpinStateActive := FALSE;			//When value is met or exceeded, then give control back to tape guidance. &#xD;
			&#xD;
			SpinstateR := SS_WaitforCenter;	//move to next state. &#xD;
	&#xD;
		END_IF;&#xD;
		&#xD;
		&#xD;
	SS_WaitforCenter:&#xD;
	&#xD;
		IF (AZD_ActPos &gt;= 10900) THEN&#xD;
			&#xD;
			SpinStateComplete 	:= TRUE;		//Set true and set AGV running state to true. &#xD;
			SS_BLV_Stp			:= FALSE;		//Set BLV stop mode to false to release brakes. &#xD;
			SpinStateActive 	:= FALSE;		//Set spinstate active bool false. &#xD;
			SS_BLV_MBFREE		:= FALSE;		//set Drive motor breaks free. &#xD;
			TagDriveSetR 		:= FALSE;&#xD;
			SpinstateR := SS_Complete;	//move to next state. &#xD;
			&#xD;
		ELSIF (TimeInState = 6000) AND (AZD_ActPos &lt; 10900) THEN&#xD;
			&#xD;
			PrevSetPos := 0;&#xD;
			AZD_SetPos :=  Steering_RightPos;&#xD;
			Inc(RetryCount);&#xD;
			SpinstateR := SS_AZDCenter;&#xD;
		&#xD;
			&#xD;
		ELSIF (AZD_SW_Fault) &#xD;
				OR (RetryCount = 3) &#xD;
				THEN&#xD;
			&#xD;
			SpinstateR := SS_HandleFault; //Drive fault detected, handle fault state.&#xD;
		END_IF;&#xD;
	&#xD;
	&#xD;
	SS_Complete:&#xD;
	&#xD;
	IF AZD_ActPos &lt;=Steering_Home THEN&#xD;
		&#xD;
		SpinPause 			:= FALSE;			//Set all to false except spinstatecomplete and return to idle state. &#xD;
		Spinright			:= FALSE;&#xD;
		TagSpin 			:= FALSE;&#xD;
		SpinStateActive 	:= FALSE;&#xD;
		SpinSetSpeed    	:= FALSE;&#xD;
		DriveSpin       	:= FALSE;&#xD;
		SpinStateComplete   := TRUE;&#xD;
		&#xD;
		RetryCount := 0; &#xD;
		&#xD;
		SpinstateR := SS_idle; // return to idle state when complete.&#xD;
	END_IF;&#xD;
	&#xD;
	&#xD;
	SS_HandleFault:&#xD;
	&#xD;
		SpinPause 			:= FALSE;&#xD;
		TagDriveSetR 		:= FALSE;&#xD;
		Spinright			:= FALSE;&#xD;
		TagSpin 			:= FALSE;&#xD;
		SpinStateActive 	:= FALSE;&#xD;
		SpinSetSpeed    	:= FALSE;&#xD;
		DriveSpin       	:= FALSE;&#xD;
		SS_BLV_Stp			:= FALSE;&#xD;
		SS_BLV_MBFREE		:= FALSE;&#xD;
		SpinStateReset 		:=  TRUE;&#xD;
		RetryCount		:= 0;&#xD;
		&#xD;
		SpinstateR := SS_idle;&#xD;
&#xD;
			&#xD;
&#xD;
	SS_Reset:				//When Reset state, Turn all Variables off and return to idle state. &#xD;
	&#xD;
	IF SpinStateReset THEN&#xD;
		&#xD;
		SpinPause 			:= FALSE;&#xD;
		TagDriveSetR 		:= FALSE;&#xD;
		Spinright			:= FALSE;&#xD;
		TagSpin 			:= FALSE;&#xD;
		SpinStateActive 	:= FALSE;&#xD;
		SpinSetSpeed    	:= FALSE;&#xD;
		DriveSpin       	:= FALSE;&#xD;
		SS_BLV_Stp			:= FALSE;&#xD;
		SS_BLV_MBFREE		:= FALSE;&#xD;
	&#xD;
		&#xD;
		SpinstateR := SS_idle;&#xD;
		&#xD;
	END_IF;&#xD;
	&#xD;
&#xD;
END_CASE; &#xD;
&#xD;
/////////////////////////////////////////////////////////////&#xD;
&#xD;
IF SpinstateR &lt;&gt; Prev_Spinstate OR SpinstateR = SS_idle THEN&#xD;
	TimeInState := 0;&#xD;
	&#xD;
ELSE&#xD;
	Inc(TimeInState);&#xD;
END_IF;&#xD;
&#xD;
Prev_Spinstate  := SpinstateR;&#xD;
&#xD;
&#xD;
</Text></StructuredTextModel>