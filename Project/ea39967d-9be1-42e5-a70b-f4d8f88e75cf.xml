<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>Sensor.AsWord := SensorWord;&#xD;
&#xD;
IF Direction = TurnLeft THEN&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[14]:=FALSE;											(* Falling Edge 14 *)&#xD;
	IF Sensor.Bit[14]=TRUE THEN										(* Rising Edge 14 *)&#xD;
		RisingEdge[14]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[14]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 13 TO 0 BY -1 DO&#xD;
		IF (NOT Sensor.Bit[a] AND Sensor.Bit[a+1]) OR (FallingEdge[a+1]=TRUE) THEN					(* Falling Edge a *)&#xD;
			FallingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a+1]=TRUE) OR ((Sensor.Bit[a]=TRUE)AND(Sensor.Bit[a+1]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
(* Right Turn *)&#xD;
	(* Find Falling And Rising Edge *)&#xD;
	FallingEdge[0]:=FALSE;												(* Falling Edge 0 *)&#xD;
	IF Sensor.Bit[0]=TRUE THEN											(* Rising Edge 0 *)&#xD;
		RisingEdge[0]:=TRUE;&#xD;
	ELSE&#xD;
		RisingEdge[0]:=FALSE;&#xD;
	END_IF;&#xD;
	FOR a := 0 TO 13 DO&#xD;
		IF (NOT Sensor.Bit[a+1] AND Sensor.Bit[a]) OR (FallingEdge[a]=TRUE) THEN						(* Falling Edge a *)&#xD;
			FallingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			FallingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
		IF (RisingEdge[a]=TRUE) OR ((Sensor.Bit[a+1]=TRUE)AND(Sensor.Bit[a]=FALSE)) THEN	(* Rising Edge a *)&#xD;
			RisingEdge[a+1]:=TRUE;&#xD;
		ELSE&#xD;
			RisingEdge[a+1]:=FALSE;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
RisingEdges := 0;&#xD;
FallingEdges := 0;&#xD;
FOR a := 0 TO 13 DO&#xD;
	IF RisingEdge[a] THEN Inc(RisingEdges); END_IF;&#xD;
	IF FallingEdge[a] THEN Inc(FallingEdges); END_IF;&#xD;
END_FOR;&#xD;
(* Set Active Sensors *)&#xD;
TempSensorPosition := 0.0;&#xD;
TempNoSensors := 0;&#xD;
MaxSensors := 3;&#xD;
IF Direction = TurnRight THEN&#xD;
	FOR a := 0 TO 14 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
ELSE&#xD;
	FOR a := 14 TO 0 BY -1 DO&#xD;
		IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE)) AND (TempNoSensors&lt;MaxSensors)) THEN&#xD;
			TempSensorPosition := TempSensorPosition + (INT_TO_REAL(a)+1.0);&#xD;
			Inc(TempNoSensors);&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
IF (TempSensorPosition &gt; 0.0) AND (TempNoSensors &gt; 0) THEN&#xD;
	SensorPosition := (TempSensorPosition/INT_TO_REAL(TempNoSensors));&#xD;
ELSE&#xD;
	SensorPosition := 7.0;&#xD;
END_IF;&#xD;
IF SensorPosition &gt; 14.0 THEN SensorPosition := 14.0; END_IF;&#xD;
Error := (SensorPosition - 8.0) / 7.0; // Normalise: -1 to 1, center 0&#xD;
&#xD;
(* Determine Sensor count *)&#xD;
SensorCount := 0;&#xD;
FOR a := 0 TO 14 DO&#xD;
	IF (((Sensor.Bit[a]=TRUE) AND (FallingEdge[a]=FALSE) AND (RisingEdge[a]=TRUE))) THEN&#xD;
		SensorCount := SensorCount + 1.0;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
&#xD;
(* If Sensor count too great, then override Sensor position to middle value*)&#xD;
If SensorCount &gt;= 8 THEN&#xD;
	Error := 0;&#xD;
END_IF;&#xD;
&#xD;
// Outputs&#xD;
ForkDetect := SensorCount &gt; 5.0;&#xD;
OffTrack := SensorCount = 0;&#xD;
Offset := Error;</Text></StructuredTextModel>