<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>AryByteTo(TagBytesHigh[0], UINT#2, _HIGH_LOW, TagHighWord);&#xD;
AryByteTo(TagBytesLow[0],  UINT#2, _HIGH_LOW, TagLowWord);&#xD;
AryByteTo(RFIDInWord[0], UINT#2, _HIGH_LOW, StatusWord.AsWord);&#xD;
&#xD;
RFIDOutWord[1] := BYTE#16#1;&#xD;
&#xD;
Reader_ReadOK  := StatusWord.Bit[8];&#xD;
Reader_WriteOK := StatusWord.Bit[9];&#xD;
Reader_Active  := StatusWord.Bit[10];&#xD;
Reader_Error   := StatusWord.Bit[11];&#xD;
&#xD;
// Process new tag if read ok, data has changed &amp; high word is nonzero.&#xD;
NewTagRead := Reader_ReadOK &#xD;
AND	(PrevTagHigh &lt;&gt; TagHighWord&#xD;
	OR PrevTagLow &lt;&gt; TagLowWord)&#xD;
AND TagHighWord &lt;&gt; WORD#16#0;&#xD;
&#xD;
IF TagHighWord &lt;&gt; 0 THEN &#xD;
	PrevTagHigh := TagHighWord; &#xD;
	PrevTagLow := TagLowWord;&#xD;
END_IF;&#xD;
&#xD;
IF NewTagRead THEN&#xD;
CASE WORD_TO_INT(TagHighWord) OF&#xD;
	INT#16#FFFF:&#xD;
		CASE WORD_TO_INT(TagLowWord) OF&#xD;
			INT#16#0001:&#xD;
				// Manual Stop&#xD;
				StopAGV := TRUE;&#xD;
			INT#16#0002:&#xD;
				// Keep Left&#xD;
				AGVDirection := TurnLeft;&#xD;
			INT#16#0003:&#xD;
				// Keep Right&#xD;
				AGVDirection := TurnRight;&#xD;
			INT#16#0004:&#xD;
				// Auto Stop&#xD;
				StopAGV := TRUE;&#xD;
				WaitAutoStart := TRUE;&#xD;
			INT#16#0006:&#xD;
				// Beep On&#xD;
				TagRequestBeep := TRUE;&#xD;
				&#xD;
			INT#16#0007:&#xD;
				// Low Priority&#xD;
				LowPriority := TRUE;&#xD;
				&#xD;
			INT#16#0008:&#xD;
				// High Priority&#xD;
				LowPriority := FALSE;&#xD;
				&#xD;
			INT#16#0009:&#xD;
				// Slow Speed&#xD;
				TagRequestedSpeed := Slow;&#xD;
				&#xD;
			INT#16#000A:&#xD;
				// Medium Speed&#xD;
				TagRequestedSpeed := Medium;&#xD;
				&#xD;
			INT#16#000B:&#xD;
				// Fast Speed&#xD;
				TagRequestedSpeed := Fast;&#xD;
				&#xD;
			INT#16#0016:&#xD;
				//Spin left&#xD;
				Spinleft := TRUE;&#xD;
				&#xD;
			&#xD;
			INT#16#0018:&#xD;
				//Spin Right&#xD;
				Spinright := TRUE;&#xD;
				&#xD;
			INT#16#0020:&#xD;
				//Set AZD drive to Homepos for test purpose only. &#xD;
				TagReqTest := TRUE;&#xD;
				&#xD;
			INT#16#0021:&#xD;
				//set test to a complete state.&#xD;
				TagReqTestFinish :=  TRUE;&#xD;
				&#xD;
				&#xD;
			&#xD;
			INT#16#000C:&#xD;
				// Trolley Scanfield&#xD;
			INT#16#000E:&#xD;
				// Wait Warning Field Clear&#xD;
			INT#16#000F:&#xD;
				// Store Exit&#xD;
			INT#16#0010:&#xD;
				// Catch Up&#xD;
			INT#16#0011:&#xD;
				// Drop Manual&#xD;
			INT#16#0012:&#xD;
				// Beep Off&#xD;
				TagRequestBeep := FALSE;&#xD;
			INT#16#0013:&#xD;
				// Auto Drop&#xD;
			INT#16#0014:&#xD;
				// Stop if No Trolley&#xD;
				UnknownTag := FALSE;&#xD;
		ELSE&#xD;
				// Unknown Tag Fault&#xD;
				UnknownTag := TRUE;&#xD;
		END_CASE;&#xD;
		&#xD;
	INT#16#FE20:&#xD;
		// Wait at Station&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN		&#xD;
				WaitUntil := ADD_DT_TIME(GetTime(),Param.WaitAtStop);&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
		&#xD;
	INT#16#FE21:&#xD;
		// Set Speed&#xD;
		TagRequestedSpeed := Custom;&#xD;
		TagSpeed := WORD_TO_REAL(TagLowWord);&#xD;
		&#xD;
	INT#16#FE22:&#xD;
		// Position&#xD;
		ToSupervisor.Position := WORD_BCD_TO_INT(TagLowWord);&#xD;
		&#xD;
		&#xD;
	INT#16#FE23:&#xD;
		// Process Speed&#xD;
	INT#16#FE24:&#xD;
		// Wait flag X&#xD;
	INT#16#FE25:&#xD;
		// Increment Flag x&#xD;
	INT#16#FE26:&#xD;
		// Decrement Flag x&#xD;
	INT#16#FE27:&#xD;
		// Left if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			AGVDirection := TurnLeft;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE28:&#xD;
		// Right if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			AGVDirection := TurnRight;&#xD;
		END_IF;&#xD;
		&#xD;
	//&#xD;
	//Start of spin state tags//&#xD;
	//&#xD;
	&#xD;
	INT#16#FE44:&#xD;
		//Spin Left 90 deg if Station X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			LS_90Deg := TRUE; &#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE45:&#xD;
		//Spin Right 90 deg if Station X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			RS_90Deg := TRUE; &#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE46:&#xD;
		//Spin Left 180 deg if Station X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			LS_180Deg := TRUE; &#xD;
		END_IF;&#xD;
	&#xD;
	INT#16#FE47:&#xD;
		//Spin Right 180 deg if Station X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			RS_180Deg := TRUE; &#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE29:	&#xD;
		// Manual Stop if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN		&#xD;
				RequestStopAGV := TRUE;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
		&#xD;
	INT#16#FE2A:&#xD;
		// Left if Zone X&#xD;
		IF TestABit(TagLowWord,WORD_TO_USINT(SHR(ToSupervisor.NextStation,12))) THEN&#xD;
			AGVDirection := TurnLeft;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE2B:&#xD;
		// Right if Zone X&#xD;
			IF TestABit(TagLowWord,WORD_TO_USINT(SHR(ToSupervisor.NextStation,12))) THEN&#xD;
			AGVDirection := TurnRight;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE2C:&#xD;
		// GOTO&#xD;
		ToSupervisor.NextStation := TagLowWord;&#xD;
		&#xD;
	INT#16#FE2D:&#xD;
		// Auto Drop if X&#xD;
	INT#16#FE2E:&#xD;
		// Set Scanfield&#xD;
		Scanfield.AsWord := TagLowWord;&#xD;
		&#xD;
	INT#16#FE2F:&#xD;
		// Wait X ms&#xD;
		TagRequestWait := TRUE;&#xD;
		TagWaitTime := SecToTime(WORD_TO_INT(TagLowWord));&#xD;
		&#xD;
	INT#16#FE30:&#xD;
		// Function X&#xD;
		&#xD;
	INT#16#FE31:	&#xD;
		// Slow if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			TagRequestedSpeed := Slow;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE32:	&#xD;
		// Medium if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			TagRequestedSpeed := Medium;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE33:	&#xD;
		// Fast if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			TagRequestedSpeed := Fast;&#xD;
		END_IF;&#xD;
&#xD;
	INT#16#FE34:	&#xD;
		// Load Left if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			// If Conveyor Enabled, Load&#xD;
			IF Param.ConveyorEnable OR Param.PalletConveyorEnable THEN&#xD;
				LoadFromLeft.Request := TRUE;&#xD;
			// If Conveyor Disabled, Treat as Normal Station&#xD;
			ELSE&#xD;
				RequestStopAGV := TRUE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
		&#xD;
	INT#16#FE35:	&#xD;
		// Load Right if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			// If Conveyor Enabled, Load&#xD;
			IF Param.ConveyorEnable OR Param.PalletConveyorEnable THEN&#xD;
				LoadFromRight.Request := TRUE;&#xD;
			// If Conveyor Disabled, Treat as Normal Station&#xD;
			ELSE&#xD;
				RequestStopAGV := TRUE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
	&#xD;
	INT#16#FE36:	&#xD;
		// Unload Left if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			// If Conveyor Enabled &amp; Box to Unload, Unload&#xD;
			IF (Param.ConveyorEnable OR Param.PalletConveyorEnable) AND BoxPresent THEN&#xD;
				UnloadToLeft.Request := TRUE;&#xD;
			// If Conveyor Disabled Treat as Normal Station&#xD;
			ELSIF NOT Param.ConveyorEnable AND NOT Param.PalletConveyorEnable THEN&#xD;
				RequestStopAGV := TRUE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
	&#xD;
	INT#16#FE37:	&#xD;
		// Unload Right if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord AND BoxPresent THEN&#xD;
			// If Conveyor Enabled &amp; Box to Unload, Unload&#xD;
			IF (Param.ConveyorEnable OR Param.PalletConveyorEnable) AND BoxPresent THEN&#xD;
				UnloadToRight.Request := TRUE;&#xD;
			// If Conveyor Disabled Treat as Normal Station&#xD;
			ELSIF NOT Param.ConveyorEnable AND NOT Param.PalletConveyorEnable THEN&#xD;
				RequestStopAGV := TRUE;&#xD;
			END_IF;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;&#xD;
	&#xD;
	INT#16#FE38:&#xD;
		// Station speed if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN&#xD;
			TagRequestedSpeed := Custom;&#xD;
			TagSpeed := Param.StationSpeed;&#xD;
		END_IF;&#xD;
		&#xD;
	INT#16#FE39:&#xD;
		// Block Entry&#xD;
		ToSupervisor.Block := WORD_BCD_TO_INT(TagLowWord);&#xD;
&#xD;
	INT#16#FE40:	&#xD;
		// Auto Stop if X&#xD;
		IF ToSupervisor.NextStation = TagLowWord THEN		&#xD;
				RequestStopAGV := TRUE;&#xD;
				WaitAutoStart := TRUE;&#xD;
		END_IF;&#xD;
		ToSupervisor.LastStation := TagLowWord;	&#xD;
&#xD;
	INT#16#FC01:&#xD;
		// Wait at Stop Param&#xD;
		Param.WaitAtStop := SecToTime(WORD_TO_INT(TagLowWord));&#xD;
		&#xD;
	INT#16#FC02:&#xD;
		// Beep at Stop Param&#xD;
		Param.BeepAtStop := SecToTime(WORD_TO_INT(TagLowWord));&#xD;
		&#xD;
	INT#16#FC03:&#xD;
		// Beep in Scan Zone Param&#xD;
			Param.BeepInScanfield := SecToTime(WORD_TO_INT(TagLowWord));&#xD;
			&#xD;
	INT#16#FC10:&#xD;
		// Brake at stop param&#xD;
		Param.BrakeAtStop := TagLowWord &gt; 0;&#xD;
		&#xD;
	INT#16#FC11:&#xD;
		// Rapid stop param&#xD;
		Param.RapidStop := TagLowWord &gt; 0;&#xD;
	&#xD;
	INT#16#FC12:&#xD;
		// Station speed param&#xD;
		Param.StationSpeed := WORD_TO_REAL(TagLowWord);&#xD;
		IF Param.StationSpeed &gt; StoredSpeed.Slow THEN&#xD;
			Param.StationSpeed := StoredSpeed.Slow;&#xD;
		ELSIF Param.StationSpeed &lt; 40 THEN&#xD;
			Param.StationSpeed := 40;&#xD;
		END_IF;&#xD;
	&#xD;
	INT#16#FC13:&#xD;
		// Init Drives Tag&#xD;
		TagRequestDriveInit := TRUE;&#xD;
	&#xD;
	INT#16#0:&#xD;
		UnknownTag := FALSE;&#xD;
	ELSE&#xD;
		UnknownTag := TRUE;&#xD;
END_CASE;&#xD;
LastTagHighWord := CurrentTagHighWord;&#xD;
LastTagLowWord  := CurrentTagLowWord;&#xD;
CurrentTagHighWord := TagHighWord;&#xD;
CurrentTagLowWord  := TagLowWord;&#xD;
END_IF;</Text></StructuredTextModel>